# 2.1. 러스트란?

러스트는 2015년에는 1.0을 리리스한 새로운 프로그래밍 언어입니다.

* 러스트는 C++와 유사한 정적 컨파일 언어입니다.

  * `rustc`는 LLVM을 백어넷으로 사용합니다.
* 러스트는 다양한 플랫폼과 아키텍쳐를 지원합니다.

  * x86, ARM, WebAssembly...
* 러스트는 다양한 장치에서 사용될 수 있습니다.

  * 펜웨어가 및 부트로더 (embedded)
  * 스마트 디스플레이
  * 스마트폰
  * 데스크탑
  * 서버

C++가 사용되는 대부분의 곳에서 사용가능\uud569니다.

* 높은 유연성
* 높은 수준의 제어
* 마이크로 컬틀로러 같은 매우 제한된 장치로 스케일 다운 가능
* 변환자 또는 개변된 런트샵을 필요로 하지 않으며, 개빈 콜론도 없습니다.
* 성능을 타프하지 않으며도 안전성과 안전에 중점을 두어 개발됩니다.

# 2.2. Rust의 이점

러스트만의 독특한 세일즈 포인트(장점):

* 컴파일 시간 메모리 안전:

  * 메모리 버그 및 해제의 전체 클래스를 컴파일 시간에 방지
  * 초기화되지 않은 변수가 없음
  * 메모리 이중 해제 정보가 원천적으로 무료
  * 메모리 해제 후 사용이 원천적으로 무료
  * NULL 포인터가 없음
  * 무테크스 대여 내역을 잊는 실수를 살아줄 수 없음
  * 스레드간 데이터 레이스를 막아주며
  * 반복자가 가지고 있는 경우 무효화 되는 일이 없음

* 정의되지 않은 런타임 동작이 없음

  * 배열 접근시 경계 체크
  * 정수 타입에서 오버플로우 발생시 동작 정의됨

* 최신 언어 기능:

  * 여름형과 패턴 매칭
  * 제네릭 (generics)
  * FFI (런트키린 연락)의 런트오베허 없음
  * 비습적인 추작화
  * 컴파일러 오류 메시지가 편치
  * 내장 종소성 관리자 (Cargo)
  * 내장 테스트 진행 지원
  * LSP (언어 서버 프로톡)의 지원 수준 공규

# 2.3. Hello World!

가장 간단한 러스트 프로그램을 작성해 보고, 고정적인 `Hello World`를 보여줄게요.

```rust
fn main() {
    println!("Hello World!");
}
```

확인 할 수 있는 것들:

* 함수는 `fn` 으로 선언
* C/C++ 와 마찬가지로 중갑화 `{}` 보호로 블록 표시
* `main` 함수는 프로그램 진입점
* `println!` 은 러스트의 메시지 출력 매크로 (hygienic macro)
* 러스트의 문자열은 UTF-8으로 인코딩되어 이모지 포함

# 3.2. 변수

```rust
fn main() {
    let x: i32 = 10;
    println!("x: {x}");
    // x = 20;
    // println!("x: {x}");
}
```

* `x = 20`의 주석 처리를 삭제하면 변수가 기본적으로 불변이라는 것을 보여주지요.
* `mut` 키워드를 추가해서 변경을 허용할 수 있습니다.
* `i32`는 32비트 정수 타입입니다.

# 3.3. 값

| 타입       | 리터럴 값                          |                        |
| -------- | ------------------------------ | ---------------------- |
| 부평수있는 정수 | i8, i16, i32, i64, i128, isize | -10, 0, 1\_000, 123i64 |
| 부평없는 정수  | u8, u16, u32, u64, u128, usize | 0, 1232, 10u16         |
| 부동소수     | f32, f64                       | 3.14, -10.0e20, 2.0f32 |
| 유니코드 문자  | char                           | 'a', 'b', 'c'          |
| 불리언      | bool                           | true, false            |

타입 크기:

* `iN`, `uN`, `fN` 은 N비트 크기
* `isize`, `usize` 는 포인터 크기와 같음
* `char` 는 32비트
* `bool` 는 8비트

# 3.4. 연산

```rust
fn interproduct(a: i32, b: i32, c: i32) -> i32 {
    return a * b + b * c + c * a;
}

fn main() {
    println!("결과: {}", interproduct(120, 100, 248));
}
```

# 3.5. 문자열

Rust에는 문자열 타입이 두 가지 있습니다:

* `String` (수정 가능 문자열)
* `&str` (읽기 전용 문자열, 문자열 리터럴 타입)

```rust
fn main() {
    let greeting: &str = " 인사말";
    let planet: &str = "🪐";
    let mut sentence = String::new();
    sentence.push_str(greeting);
    sentence.push_str(", ");
    sentence.push_str(planet);
    println!("마지막 문장: {}", sentence);
    println!("{:?}", &sentence[0..5]);
    // println!("{:?}", &sentence[12..13]);
}
```

# 3.6. 타입 추론

Rust는 변수가 어떻게 사용되늕를 보고 그 변수의 타입을 추론합니다.
```rust
fn take_u32(x: u32) {
    println!("u32: {x}");
}

fn take_i8(y: i8) {
    println!("i8: {y}");
}

fn main() {
    let x = 10;
    let y = 20;

    take_u32(x);
    take_i8(y);
    // take_u32(y);
}
```

# 연습문제: 피보나치
첫 번째와 두 번째 피보나치 수는 모두 ```1```입니다.

```n > 2```일때, ```n```번째 피보나치 수는 ```n-1```번째와 ```n-2```번째 피보나치 수의 합으로 재귀적으로 계산됩니다.


```n```번째 피보나치 수를 계산하는 함수 ```fib(n)```을 작성하세요.
이 함수는 언제 panic(패닉)을 일으키게 될까요?

# if 표현식

다른 언어의 if문과 똑같이 if 표현식을 사용합니다.
```rust
fn main() {
    let x = 10;
    if x == 0 {
        println!("Zero!");
    } else if x < 100 {
        println!("큰");
    } else {
        println!("거대한");
    }
}
```
게다가 if는 표현식으로 사용할 수도 있습니다. 아래 코드는 위와 동일합니다.
```rust
fn main() {
    let x = 10;
    let size = if x < 20 { "작은" } else { "대형" };
    println!("숫자 크기: {}", size);
}
```

